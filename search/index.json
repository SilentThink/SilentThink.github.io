[{"content":"Lab 3：interoperating in the world 1.介绍 到目前为止，在这门课程中，你已经以几乎完全符合标准的方式实现了传输控制协议。可以说，TCP 实现是世界上最受欢迎的单一计算机程序，存在于数十亿的设备中。大多数实现使用与你的不同的策略，但由于所有的 TCP 实现都共享一种共同的语言，它们都是可互操作的 —— 每个 TCP 实现都可以与任何其他实现成为对等方。这个检查点是关于在现实世界中测试你的 TCP 实现，并测量特定互联网路径的长期统计信息。\n如果你的 TCP 实现编写正确，你可能不需要为这个检查点编写任何代码。但是，尽管我们做出了努力，错误仍有可能逃过我们的单元测试。如果你发现问题，我们将欢迎你用 Wireshark 进行调试并修复任何错误。\n2. 准备开始 1 2 3 4 5 git fetch --all git merge origin/check4-startercode git merge upstream/check4-startercode cmake -S . -B build cmake --build build 3. 在现实世界中使用你实现的 TCP cmake --build build --target check webget\n","date":"2024-11-08T00:14:19+08:00","permalink":"https://SilentThink.github.io/p/cs144-lab-4/","title":"CS144 Lab 4"},{"content":"Lab 3：the TCP sender 0.介绍 在 Checkpoint 0 中，你实现了一个流量控制字节流（ByteStream）的抽象。在 Checkpoints 1 和 2 中，你实现了将不可靠数据报中携带的片段转换为传入字节流的工具：重组器（Reassembler）和 TCP 接收方（TCPReceiver）。\n现在，在 Checkpoint 3 中，你将实现连接的另一端。TCP 发送方（TCPSender）是一个将出站字节流转换为将成为不可靠数据报有效载荷的片段的工具。最后，在 Checkpoint 4 中，你将结合前几个实验的工作来创建一个有效的 TCP 实现：一个包含 TCP 发送方和 TCP 接收方的 TCP 对等方（TCPPeer）。你将使用这个与同学以及互联网上的真正服务器（采用TCP 协议的对等方）进行通信。\n1. Getting started 2. Checkpoint 3: The TCP Sender TCP 是一种协议，它通过不可靠的数据报可靠地传送一对流量控制的字节流（每个方向一个）。两个参与方参与 TCP 连接，并且每个参与方都是另一方的对等方。每个对等方同时充当 “发送方”（其自己的出站字节流）和 “接收方”（传入字节流）。\n本实验，你将实现 TCP 的 “发送方” 部分，负责从字节流（由某个发送方应用程序创建并写入）读取，并将该流转换为一系列传出的 TCP 段。在远程端，一个 TCP 接收方将这些段（那些到达的段 —— 它们可能并非全部都能到达）转换回原始字节流，并向发送方发送确认和窗口通告。\n你的 TCP 发送方的职责将是：\n跟踪接收方的窗口（接收带有确认号（ackno）和窗口大小的传入 TCP 接收方消息）。 在可能的情况下填充窗口，通过从字节流读取、创建新的 TCP 段（如果需要包括 SYN 和 FIN 标志）并发送它们。发送方应持续发送段，直到窗口已满或出站字节流没有更多内容可发送。 跟踪哪些段已发送但尚未被接收方确认 —— 我们称这些为 “未确认” 段。 如果自发送以来经过了足够长的时间并且它们尚未被确认，则重新发送未确认段。 2.1 TCP 发送方如何知道一个段是否丢失？ 你的 TCP 发送方将发送一堆 TCP 发送方消息。每个消息都将包含来自出站字节流的（可能为空）子字符串，用序列号进行索引以表明其在流中的位置，并在流的开头标记 SYN 标志，在结尾标记 FIN 标志。\n除了发送这些段之外，TCP 发送方还必须跟踪其未确认的段，直到它们所占用的序列号被完全确认。TCP 发送方的所有者会定期调用 TCP 发送方的tick方法，表示时间的流逝。TCP 发送方负责查看其未确认的 TCP 发送方消息集合，并确定最早发送的段在没有确认的情况下（即其所有序列号都未被确认）是否已经未确认了太长时间。如果是这样，它需要被重传（再次发送）。\n2.2 实现 TCP sender tcp_sender.hh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #pragma once #include \u0026#34;byte_stream.hh\u0026#34; #include \u0026#34;tcp_receiver_message.hh\u0026#34; #include \u0026#34;tcp_sender_message.hh\u0026#34; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;queue\u0026gt; class TCPSender { public: /* Construct TCP sender with given default Retransmission Timeout and possible ISN */ TCPSender( ByteStream\u0026amp;\u0026amp; input, Wrap32 isn, uint64_t initial_RTO_ms ) : input_( std::move( input ) ), isn_( isn ), initial_RTO_ms_( initial_RTO_ms ), cur_RTO_ms_( initial_RTO_ms ) {} /* Generate an empty TCPSenderMessage */ TCPSenderMessage make_empty_message() const; /* Receive and process a TCPReceiverMessage from the peer\u0026#39;s receiver */ void receive( const TCPReceiverMessage\u0026amp; msg ); /* Type of the `transmit` function that the push and tick methods can use to send messages */ using TransmitFunction = std::function\u0026lt;void( const TCPSenderMessage\u0026amp; )\u0026gt;; /* Push bytes from the outbound stream */ void push( const TransmitFunction\u0026amp; transmit ); /* Time has passed by the given # of milliseconds since the last time the tick() method was called */ void tick( uint64_t ms_since_last_tick, const TransmitFunction\u0026amp; transmit ); // Accessors uint64_t sequence_numbers_in_flight() const; // How many sequence numbers are outstanding? uint64_t consecutive_retransmissions() const; // How many consecutive *re*transmissions have happened? Writer\u0026amp; writer() { return input_.writer(); } const Writer\u0026amp; writer() const { return input_.writer(); } // Access input stream reader, but const-only (can\u0026#39;t read from outside) const Reader\u0026amp; reader() const { return input_.reader(); } private: // Variables initialized in constructor ByteStream input_; Wrap32 isn_; uint64_t initial_RTO_ms_; uint64_t send_cnt_ {}; uint64_t ack_cnt_ {}; uint64_t retx_cnt_ {}; uint64_t wdsz_ = 1; bool is_syn_ {}; bool is_fin_ {}; // time uint64_t timer_ {}; bool is_timer_on_ {}; std::queue\u0026lt;TCPSenderMessage\u0026gt; retx_queue_ {}; uint64_t cur_RTO_ms_; }; tcp_sender.cc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 #include \u0026#34;tcp_sender.hh\u0026#34; #include \u0026#34;byte_stream.hh\u0026#34; #include \u0026#34;tcp_config.hh\u0026#34; #include \u0026#34;tcp_sender_message.hh\u0026#34; #include \u0026#34;wrapping_integers.hh\u0026#34; #include \u0026lt;algorithm\u0026gt; using namespace std; uint64_t TCPSender::sequence_numbers_in_flight() const { return send_cnt_ - ack_cnt_; } uint64_t TCPSender::consecutive_retransmissions() const { return retx_cnt_; } void TCPSender::push( const TransmitFunction\u0026amp; transmit ) { while ((wdsz_ == 0 ? 1 : wdsz_) \u0026gt; sequence_numbers_in_flight()) { if (is_fin_) { break; } auto msg = make_empty_message(); if (!is_syn_) { msg.SYN = true; is_syn_ = true; } uint64_t remaining = (wdsz_ == 0 ? 1 : wdsz_) - sequence_numbers_in_flight(); uint64_t len = min(TCPConfig::MAX_PAYLOAD_SIZE, remaining - msg.sequence_length()); auto\u0026amp;\u0026amp; data = msg.payload; while (reader().bytes_buffered() \u0026amp;\u0026amp; data.size() \u0026lt; len) { auto cur_data = reader().peek(); cur_data = cur_data.substr(0, len - data.size()); data += cur_data; input_.reader().pop(data.size()); } if (!is_fin_ \u0026amp;\u0026amp; remaining \u0026gt; msg.sequence_length() \u0026amp;\u0026amp; reader().is_finished()) { msg.FIN = true; is_fin_ = true; } if (msg.sequence_length() == 0) { break; } transmit(msg); if (!is_timer_on_) { is_timer_on_ = true; timer_ = 0; } send_cnt_ += msg.sequence_length(); retx_queue_.emplace(msg); } } TCPSenderMessage TCPSender::make_empty_message() const { return { .seqno = Wrap32::wrap(send_cnt_, isn_), .SYN = false, .payload = {}, .FIN = false, .RST = input_.has_error() }; } void TCPSender::receive( const TCPReceiverMessage\u0026amp; msg ) { wdsz_ = msg.window_size; if (msg.RST) { input_.set_error(); return; } if (msg.ackno.has_value()) { const uint64_t recv_ackno = msg.ackno.value().unwrap(isn_, ack_cnt_); if (recv_ackno \u0026gt; send_cnt_) { return; } while (!retx_queue_.empty()) { auto retx_msg = retx_queue_.front(); if (recv_ackno \u0026lt; ack_cnt_ + retx_msg.sequence_length()) { break; } ack_cnt_ += retx_msg.sequence_length(); retx_queue_.pop(); retx_cnt_ = 0; cur_RTO_ms_ = initial_RTO_ms_; timer_ = 0; if (retx_queue_.empty()) { is_timer_on_ = false; } } } } void TCPSender::tick( uint64_t ms_since_last_tick, const TransmitFunction\u0026amp; transmit ) { if (is_timer_on_) { timer_ += ms_since_last_tick; } if (timer_ \u0026gt;= cur_RTO_ms_) { while (!retx_queue_.empty()) { auto msg = retx_queue_.front(); auto sendno = msg.seqno.unwrap(isn_, send_cnt_); if (sendno + msg.sequence_length() \u0026gt; ack_cnt_) { // if there are packets lost transmit(msg); if (wdsz_) { retx_cnt_ ++; cur_RTO_ms_ *= 2; } timer_ = 0; break; } else { retx_queue_.pop(); } } } } 测试cmake --build build --target check3：\n","date":"2024-11-07T23:56:33+08:00","permalink":"https://SilentThink.github.io/p/cs144-lab-3/","title":"CS144 Lab 3"},{"content":"Lab 2：the TCP receiver 0.介绍 在 Checkpoint 0 中，你实现了一个流量控制的字节流抽象（ByteStream）。在 Checkpoint 1 中，你创建了一个重组器（Reassembler），它接受来自同一字节流的一系列子字符串，并将它们重新组装回原始流。这些模块在你的 TCP 实现中会很有用，但它们中没有任何一个是特定于传输控制协议的细节的。现在情况发生了变化。在 Checkpoint 2 中，你将实现 TCP 接收方（TCPReceiver），这是 TCP 实现中处理传入字节流的部分。\nTCP 接收方从对等方的发送方接收消息（通过 receive () 方法），并将它们转换为对重组器的调用，重组器最终写入传入的字节流。应用程序从这个字节流中读取，就像你在实验 0 中通过从 TCPSocket 读取一样。\n同时，TCP 接收方还通过 send () 方法生成返回给对等方发送方的消息。这些 “接收方消息” 负责告诉发送方：\n“第一个未组装” 字节的索引，这被称为 “确认号”（acknowledgment number）或 “ackno”。这是接收方从发送方需要的第一个字节。 输出字节流中的可用容量。这被称为 “窗口大小”（window size）。 确认号和窗口大小一起描述了接收方的窗口：一个 TCP 发送方被允许发送的索引范围。通过使用窗口，接收方可以控制传入数据的流量，使发送方在接收方准备好接收更多数据之前限制其发送量。我们有时将确认号称为窗口的 “左边缘”（TCP 接收方想要的最小索引），将确认号加上窗口大小称为 “右边缘”（刚好超出 TCP 接收方想要的最大索引）。\n当你编写重组器和字节流时，你已经完成了实现 TCP 接收方所涉及的大部分算法工作；这个实验是关于将这些通用类连接到 TCP 的细节。最难的部分将涉及思考 TCP 如何表示每个字节在流中的位置 —— 称为 “序列号”。\n1. 准备开始 2. Checkpoint 2: The TCP Receiver 2.1 实现在 64 位索引和 32 位序列号之间进行转换 wrapping_integers.cc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026#34;wrapping_integers.hh\u0026#34; using namespace std; Wrap32 Wrap32::wrap( uint64_t n, Wrap32 zero_point ) { return Wrap32 { static_cast\u0026lt;uint32_t\u0026gt;( ( static_cast\u0026lt;uint32_t\u0026gt;( n ) + zero_point.raw_value_ ) % ( 1UL \u0026lt;\u0026lt; 32 ) ) }; } uint64_t Wrap32::unwrap( Wrap32 zero_point, uint64_t checkpoint ) const { // Calculate the difference with 32-bit wraparound handling uint64_t diff = static_cast\u0026lt;uint64_t\u0026gt;( raw_value_ - zero_point.raw_value_ ); const uint64_t MODULO = 1UL \u0026lt;\u0026lt; 32; uint64_t remainder = checkpoint % MODULO; uint64_t quotient = checkpoint / MODULO; if ( diff + MODULO - remainder \u0026gt;= MODULO + ( MODULO \u0026gt;\u0026gt; 1 ) ) { if ( quotient \u0026gt; 0 ) diff = diff + ( quotient - 1 ) * MODULO; } else if ( diff + MODULO - remainder \u0026lt; MODULO - ( MODULO \u0026gt;\u0026gt; 1 ) ) { diff = diff + ( quotient + 1 ) * MODULO; } else diff = diff + quotient * MODULO; return diff; } 2.2 实现TCP receiver tcp_receriver.hh:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #pragma once #include \u0026#34;reassembler.hh\u0026#34; #include \u0026#34;tcp_receiver_message.hh\u0026#34; #include \u0026#34;tcp_sender_message.hh\u0026#34; class TCPReceiver { public: // Construct with given Reassembler explicit TCPReceiver( Reassembler\u0026amp;\u0026amp; reassembler ) : reassembler_( std::move( reassembler ) ) {} /* * The TCPReceiver receives TCPSenderMessages, inserting their payload into the Reassembler * at the correct stream index. */ void receive( TCPSenderMessage message ); // The TCPReceiver sends TCPReceiverMessages to the peer\u0026#39;s TCPSender. TCPReceiverMessage send() const; // Access the output (only Reader is accessible non-const) const Reassembler\u0026amp; reassembler() const { return reassembler_; } Reader\u0026amp; reader() { return reassembler_.reader(); } const Reader\u0026amp; reader() const { return reassembler_.reader(); } const Writer\u0026amp; writer() const { return reassembler_.writer(); } private: Reassembler reassembler_; std::optional\u0026lt;Wrap32\u0026gt; isn_ {}; }; tcp_receiver.cc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026#34;tcp_receiver.hh\u0026#34; using namespace std; void TCPReceiver::receive( TCPSenderMessage message ) { // Your code here. if ( writer().has_error() ) { return; } if ( message.RST ) { reader().set_error(); return; } // the parameters should be translated from seqno to absolute seqno if ( !isn_.has_value() ) { if ( !message.SYN ) { return; } isn_.emplace( message.seqno ); } Wrap32 zero_point = isn_.value(); uint64_t checkpoint = writer().bytes_pushed() + 1; Wrap32 sequo = message.seqno; if ( message.SYN ) { sequo = sequo + 1; } uint64_t abs_seqno = sequo.unwrap( zero_point, checkpoint ); uint64_t stream_index = abs_seqno - 1; reassembler_.insert( stream_index, move( message.payload ), message.FIN ); } TCPReceiverMessage TCPReceiver::send() const { uint16_t wdsz = static_cast\u0026lt;uint16_t\u0026gt;( min( writer().available_capacity(), static_cast\u0026lt;uint64_t\u0026gt;( UINT16_MAX ) ) ); bool reset = writer().has_error(); if ( isn_.has_value() ) { Wrap32 ackno = Wrap32::wrap( writer().bytes_pushed() + static_cast\u0026lt;uint64_t\u0026gt;( writer().is_closed() ), isn_.value() ) + 1; return { ackno, wdsz, reset }; } else { return { nullopt, wdsz, reset }; } } 测试结果cmake --build build --target check2：\n","date":"2024-11-07T23:39:07+08:00","permalink":"https://SilentThink.github.io/p/cs144-lab-2/","title":"CS144 Lab 2"},{"content":"Lab 1：stitching substrings into a byte stream 0. 概述 在 Checkpoint 0 中，你使用互联网流套接字从网站获取信息并发送电子邮件消息，使用的是 Linux 内置的传输控制协议（TCP）实现。这个 TCP 实现设法产生了一对可靠的有序字节流（一个从你到服务器，另一个相反），即使底层网络仅提供 “尽可能可靠” 的数据报。这里的意思是：可能会丢失、重新排序、更改或重复的短数据包。你还在一台计算机的内存中自己实现了字节流抽象。在接下来的实验中，你将自己实现 TCP，以便在由不可靠数据报网络分隔的一对计算机之间提供字节流抽象。\n还记得你在 Checkpoint 0 中刚刚实现的 ByteStream 吗？在接下来的实验中，你最终将在网络上传输两个这样的字节流：“outbound” ByteStream，用于本地应用程序写入套接字并且你的 TCP 将发送给对等方的数据；以及“inbound” ByteStream，用于来自对等方并将被本地应用程序读取的数据。\n1. 准备开始 你的 TCP 实现将使用与在 Checkpoint 0 中相同的 Minnow 库，同时还有额外的类和测试。要开始进行：\n确保你已经将 Checkpoint 0 的所有解决方案都提交了。请不要修改 src 目录或 webget.cc 之外的任何文件。否则，在合并 Checkpoint 1 的起始代码时可能会遇到问题。 在实验作业的存储库中，运行 git fetch 以获取实验作业的最新版本。 通过运行 git merge origin/check1-startercode 下载 Checkpoint 1 的起始代码。（如果你将 “origin” 远程仓库重命名为其他名称，你可能需要在这里使用不同的名称，例如 git merge upstream/check1-startercode。） 确保你的构建系统已正确设置：cmake -S. -B build。 编译源代码：cmake --build build。 2. 将子字符串按顺序排列 作为实验作业的一部分，你将实现一个 TCP 接收方：这个模块接收数据报并将它们转换为可靠的字节流，以便应用程序从套接字中读取 —— 就像你的 webget 程序在 Checkpoint 0 中从网络服务器读取字节流一样。\nTCP 发送方将其字节流分割成短的片段（每个子字符串不超过约 1460 字节），以便它们都能装在一个数据报中。但是网络可能会重新排序这些数据报，或者丢弃它们，或者多次传递它们。接收方必须将这些片段重新组装成它们最初的连续字节流。\n在这个实验中，你将编写负责这种重新组装的数据结构：一个重组器（Reassembler）。它将接收子字符串，由一串字节组成，以及该字符串在较大字节流中的第一个字节的索引。字节流中的每个字节都有自己唯一的索引，从零开始向上计数。一旦重组器知道了字节流中的下一个字节，它就会将其写入到一个字节流（ByteStream）的写入端 —— 这与你在 Checkpoint 0 中实现的字节流是同一个。重组器的 “客户” 可以从同一个字节流的读取端进行读取。\n以下是这个接口的样子：\n1 2 3 4 5 6 // 插入一个新的子字符串以重新组装到字节流中。 void insert(uint64_t first_index, std::string data, bool is_last_substring); // 重组器自身存储了多少字节？ uint64_t bytes_pending() const; // 访问输出流的读取器 Reader\u0026amp; reader(); ⋆为什么要这样做呢？\nTCP 对重新排序和重复的鲁棒性来自于它能够将字节流的任意片段重新拼接回原始流的能力。在一个独立的可测试模块中实现这一点将使处理传入的片段更加容易。\n重组器的完整（公共）接口由 “reassembler.hh” 头文件中的 “Reassembler” 类描述。你的任务是实现这个类。你可以向 “Reassembler” 类添加任何你想要的私有成员和成员函数，但你不能改变它的公共接口。\n2.1 重组器在内部应该存储什么？ insert方法向重组器告知字节流的一个新片段，以及它在整个流中的位置（子字符串开头的索引）。\n原则上，重组器必须处理三类信息：\n是流中的下一个字节。一旦知道这些字节，重组器应立即将它们推送到流中（输出的 .writer()）。 适合流的可用容量但由于前面的字节仍未知而不能写入的字节。这些应该在重组器内部存储。 超出流的可用容量的字节。这些应该被丢弃。重组器不会存储任何不能立即推送到字节流中，或者一旦前面的字节变得已知也不能推送到字节流中的字节。 这种行为的目标是限制重组器和字节流使用的内存量，无论传入的子字符串如何到达。我们在下面的图片中进行了说明。“容量” 是两者的上限：\n在重组后的字节流中缓冲的字节数（显示为绿色），以及 可以由 “未组装” 的子字符串使用的字节数（显示为红色）。 reassembler.hh:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #pragma once #include \u0026#34;byte_stream.hh\u0026#34; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; struct Interval { uint64_t start; uint64_t end; std::string data; bool operator\u0026lt;(const Interval\u0026amp; other) const { if (start == other.start) { return end \u0026lt; other.end; } return start \u0026lt; other.start; } }; class Reassembler { public: // Construct Reassembler to write into given ByteStream. explicit Reassembler( ByteStream\u0026amp;\u0026amp; output ) : output_( std::move( output ) ) {} /* * Insert a new substring to be reassembled into a ByteStream. * `first_index`: the index of the first byte of the substring * `data`: the substring itself * `is_last_substring`: this substring represents the end of the stream * `output`: a mutable reference to the Writer * * The Reassembler\u0026#39;s job is to reassemble the indexed substrings (possibly out-of-order * and possibly overlapping) back into the original ByteStream. As soon as the Reassembler * learns the next byte in the stream, it should write it to the output. * * If the Reassembler learns about bytes that fit within the stream\u0026#39;s available capacity * but can\u0026#39;t yet be written (because earlier bytes remain unknown), it should store them * internally until the gaps are filled in. * * The Reassembler should discard any bytes that lie beyond the stream\u0026#39;s available capacity * (i.e., bytes that couldn\u0026#39;t be written even if earlier gaps get filled in). * * The Reassembler should close the stream after writing the last byte. */ void insert( uint64_t first_index, std::string data, bool is_last_substring ); // How many bytes are stored in the Reassembler itself? uint64_t bytes_pending() const; // Access output stream reader Reader\u0026amp; reader() { return output_.reader(); } const Reader\u0026amp; reader() const { return output_.reader(); } // Access output stream writer, but const-only (can\u0026#39;t write from outside) const Writer\u0026amp; writer() const { return output_.writer(); } private: ByteStream output_; // the Reassembler writes to this ByteStream std::set\u0026lt;Interval\u0026gt; buf_{}; uint64_t nxt_expected_idx_ = 0; uint64_t eof_idx_ = UINT64_MAX; }; reassembler.cc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026#34;reassembler.hh\u0026#34; using namespace std; void Reassembler::insert( uint64_t first_index, string data, bool is_last_substring ) { uint64_t wd_start = nxt_expected_idx_; uint64_t wd_end = wd_start + output_.writer().available_capacity(); uint64_t cur_start = first_index; uint64_t cur_end = cur_start + data.size(); // set the eof index of this reassembling if (is_last_substring) { eof_idx_ = cur_end; } if (cur_start \u0026gt;= wd_end) { if (nxt_expected_idx_ == eof_idx_) { output_.writer().close(); } return; } uint64_t start_idx = max(wd_start, cur_start); uint64_t end_idx = min(wd_end, cur_end); if (start_idx \u0026gt;= end_idx) { if (nxt_expected_idx_ == eof_idx_) { output_.writer().close(); } return; } uint64_t len = end_idx - start_idx; // insert the current data buf_.insert({start_idx, end_idx, data.substr(start_idx - first_index, len)}); // handle the overlapping of intervals std::vector\u0026lt;Interval\u0026gt; merged; auto it = buf_.begin(); Interval last = *it; it ++; while (it != buf_.end()) { if (it-\u0026gt;start \u0026lt;= last.end) { if (last.end \u0026lt; it-\u0026gt;end) { last.end = it-\u0026gt;end; last.data = last.data.substr(0, it-\u0026gt;start - last.start) + it-\u0026gt;data; } } else { merged.push_back(last); last = *it; } it ++; } merged.push_back(last); buf_.clear(); for (const auto\u0026amp; interval : merged) { buf_.insert(interval); } // push when it ready it = buf_.begin(); while (it-\u0026gt;start == nxt_expected_idx_) { output_.writer().push(it-\u0026gt;data); nxt_expected_idx_ = it-\u0026gt;end; it = buf_.erase(it); } // close when all bytes are pushed if (nxt_expected_idx_ == eof_idx_) { output_.writer().close(); } } uint64_t Reassembler::bytes_pending() const { uint64_t pendcnt = 0; for (const auto\u0026amp; interval : buf_) { pendcnt += interval.end - interval.start; } return pendcnt; } 3. 开发和调试建议 你可以使用cmake --build build --target check1（在编译代码后）来测试你的代码。 请重新阅读实验 0 文档中的 “使用 Git” 部分，并记住将代码保存在分发时所在的 Git 仓库的主分支上。进行小的提交，使用良好的提交消息来标识更改了什么以及为什么更改。 请努力使你的代码对为其进行风格和正确性评分的课程助理来说是可读的。为变量使用合理和清晰的命名约定。使用注释来解释复杂或微妙的代码部分。使用 “防御性编程”—— 显式检查函数的前置条件或不变量，如果有任何错误则抛出异常。在你的设计中使用模块化 —— 识别常见的抽象和行为，并在可能的情况下将它们提取出来。重复的代码块和巨大的函数会使你的代码难以理解。 也请保持在 Checkpoint 0 文档中描述的 “现代 C++” 风格。cppreference 网站（https://en.cppreference.com）是一个很好的资源，尽管你在做这些实验时不需要 C++ 的任何复杂特性。（有时你可能需要使用move()函数来传递一个不能被复制的对象。） 如果你在构建时遇到问题并且不确定如何修复，可以删除你的构建目录（rm -rf build—— 请小心不要输入错误，因为这将删除你指定的任何内容），然后再次运行cmake -S. -B build。 check1测试结果：\n","date":"2024-11-07T22:50:09+08:00","permalink":"https://SilentThink.github.io/p/cs144-lab-1/","title":"CS144 Lab 1"},{"content":" Lab 0：networking warmup 0.介绍 本次热身任务中，你需要在自己的计算机上安装 Linux 系统，学习如何手动通过互联网执行一些任务，用 C++ 编写一个小程序从互联网上获取网页，并在内存中实现网络的一个关键抽象概念：在写入者和读取者之间的可靠字节流。\n1. GNU/Linux环境配置 windows: 我使用的环境为Ubuntu 22.04 @ WSL2\n运行以下命令安装需要的包\n1 2 sudo apt update \u0026amp;\u0026amp; sudo apt install git cmake gdb build-essential clang \\ clang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark 项目编译运行及调试需要的g++ 版本:13及以上\nMac OS: 官方文档中的建议：\nIf you have a 2020–24 MacBook (with the ARM64 M1/M2/M3 chips), VirtualBox will\nnot successfully run. Instead, please install the UTM virtual machine software and our\nARM64 virtual machine image from https://stanford.edu/class/cs144/vm_howto/ .\n我的配置方法——docker:\ndockerfile:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 FROM ubuntu:latest WORKDIR /usr/src/app RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ build-essential \\ g++-13 \\ clang-15 RUN update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-13 100 \\ \u0026amp;\u0026amp; update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-13 100 \\ \u0026amp;\u0026amp; update-alternatives --install /usr/bin/clang clang /usr/bin/clang-15 100 ENV CC=gcc ENV CXX=g++ RUN apt-get clean \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* CMD [ \u0026#34;/bin/bash\u0026#34;] 2. 手动完成网络任务 在 “Networking by hand” 部分，你需要手动完成两项任务：检索网页（就像网络浏览器一样）和发送电子邮件消息（就像电子邮件客户端一样）。这两项任务都依赖于一种称为可靠双向字节流的网络抽象概念。你将在终端中输入一系列字节，相同顺序的字节序列最终将被传递到另一台计算机（服务器）上运行的程序。服务器用它自己的字节序列进行响应，并将其传递回你的终端。\n2.1 获取一个网页 打开浏览器访问 http://cs144.keithw.org/hello 并观察结果 在linux终端中执行和浏览器一样的工作 ​\t(a) 运行 telnet cs144.keithw.org http\n这会告诉 telnet 程序在你的计算机和另一台名为 “cs144.keithw.org” 的计算机之间打开一个可靠的字节流，并且在那台计算机上运行特定的服务：用于万维网的超文本传输协议（“http” 服务）。如果你的计算机已正确设置并连接到互联网，你将看到如上图相应的输出。\n如果你想要退出这个连接，按住键盘的 ctrl 键然后按 ]，之后敲下回车键 Enter 即可 (b) 输入 GET /hello HTTP/1.1，这告诉服务器 URL 的路径部分（从第三个斜杠开始的部分）。\n​\t(c) 输入 Host: cs144.keithw.org，这告诉服务器 URL 的主机部分（在 “http://” 和第三个斜杠之间的部分）。\n​\t(d) 输入 Connection: close，这告诉服务器你已完成请求，并且它应在回复完成后尽快关闭连接。\n​\t(e) 再按一次回车键，这发送一个空行并告诉服务器你已完成 HTTP 请求。\n​\t(f) 如果一切顺利，你将看到与浏览器看到的相同响应，前面是 HTTP 头，它告诉浏览器如何解释响应。\n2.2 给自己发邮件 略：没有斯坦福的邮箱，无法完成这个任务\n2.3 监听与连接 你已经看到了用 telnet 能做什么：它是一个客户端程序，可以与其他计算机上运行的程序建立外出连接。现在是时候尝试运行一个简单的服务器了：即等待客户端连接它的程序。\n在一个终端窗口中，在你的虚拟机上运行 netcat -v -l -p 9090。\n让 netcat 保持运行状态。在另一个终端窗口中，运行 telnet localhost 9090。\n如果一切顺利，netcat 将会打印出类似 “Connection from localhost 53500 received! ” 的内容。\n现在尝试在任意一个终端窗口中输入内容 —— 无论是 netcat（服务器）窗口还是 telnet（客户端）窗口。注意，你在一个窗口中输入的任何内容都会出现在另一个窗口中，反之亦然。你必须按回车键才能传输字节。\n在 netcat 窗口中，通过输入 ctrl-C 退出程序。注意，telnet 程序也会立即退出。\n3. 使用操作系统流套接字编写网络程序 在本次热身实验的下一部分，你要编写一个简短程序从互联网获取网页。这会利用 Linux 内核及大多数其他操作系统提供的功能，即在两个程序间创建可靠双向字节流，比如一个程序在你的计算机上运行，另一个在互联网上的其他计算机（如 Web 服务器或 netcat 程序）上运行。此功能称为流套接字，对于程序和 Web 服务器来说，它就像普通文件描述符。\n但实际上，互联网并不直接提供可靠字节流服务，只是尽最大努力传送数据报，而数据报可能丢失、乱序、内容改变甚至被复制多次。连接两端的操作系统通常负责将 “尽力而为的数据报” 转换为 “可靠字节流”，这是通过 1981 年的传输控制协议（TCP）实现的。\n在本次实验中，你将借助操作系统对 TCP 的支持编写 “webget” 程序，创建 TCP 流套接字连接 Web 服务器获取页面。未来的实验中，你将自己实现传输控制协议，从不太可靠的数据报中创建可靠字节流。\n3.1 获取并部署原始代码 运行 git clone https://github.com/cs144/minnow 拉取代码 将项目部署到自己的github仓库 进入 Lab 0 的目录：cd minnow 创建build目录来编译程序： cmake -S . -B build 编译源代码：cmake --build build 查看是否安装g++13版本，对应的路径在哪：\n配置默认编译器：nano ~/.bashrc，在文件末尾添加以下两行代码：\n1 2 export CC=gcc-13 export CXX=g++-13 ctrl+x,Enter 进行保存\n运行source ~/.bashrc进行更新\n创建build目录\n编译\n3.2 现代C++编码规范 参考：\nhttp://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines\nhttps://en.cppreference.com\n具体请看源文档：check0.pdf\n在push到github之前，运行 cmake --build build --target tidy 以获取有关如何改进与 C++ 编程实践相关的代码的建议，并运行 cmake --build build --target format 以一致地格式化代码。\n使用git:\nPlease make frequent small commits as you work, and use commit messages that identify what changed and why\n参考：\nhttps://guides.github.com/introduction/git-handbook\n3.3 阅读 Minnow 提供的源代码框架 请仔细阅读公共接口（在文件 util/socket.hh 和 util/file_descriptor.hh 中 “public:” 之后的部分。请注意，Socket 是一种 FileDescriptor 类型，而 TCPSocket 是一种 Socket 类型）。\n3.4 编写 webget 现在是时候实现 “webget” 了，这是一个使用操作系统的 TCP 支持和流套接字抽象从互联网上获取网页的程序 —— 就像你在本次实验的早些时候手动所做的那样。\n从构建目录中，在文本编辑器或集成开发环境（IDE）中打开 “../apps/webget.cc” 文件。 在 “get_URL” 函数中实现简单的 Web 客户端。 按照文件中的描述，使用之前用过的 HTTP（Web）请求格式。同时要使用 “TCPSocket” 和 “Address” 类。 明确了实现的具体位置和所需的类。 提示： 在 HTTP 中，每行必须以 “\\r\\n” 结尾，不能仅用 “\\n” 或 “endl”。强调了 HTTP 协议的格式要求。 客户端请求中要包含 “Connection: close”，告知服务器在本次请求后不再等待更多请求，服务器发送一个回复后就结束传出字节流。当套接字到达 “EOF” 时，表明传入字节流结束，客户端由此知道服务器已完成回复。详细说明了与服务器交互的关键设置。 确保读取并打印服务器的所有输出直到套接字到达 “EOF”，单次调用 “read” 是不够的。强调了要完整处理服务器的响应。 预计需要写大约十行代码，给出了代码量的大致预期。 通过运行 make 编译程序。\n测试程序。\n运行 ./apps/webget cs144.keithw.org /hello 进行测试。 比较与在浏览器中访问 “http://cs144.keithw.org/hello” 的结果以及与 2.1 节结果的差异。鼓励用任何 http URL 进行实验。 自动化测试： 当程序看似正常工作时，运行 “cmake --build build --target check webget” 进行自动化测试。 在实现 “get_URL” 函数之前，会看到特定的测试结果，包括编译检查通过但功能测试失败，并给出警告和错误信息。完成作业后，测试应全部通过。 webget.cc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026#34;socket.hh\u0026#34; #include \u0026#34;tcp_minnow_socket.hh\u0026#34; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;span\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void get_URL( const string\u0026amp; host, const string\u0026amp; path ) { CS144TCPSocket sock {}; sock.connect( Address( host, \u0026#34;http\u0026#34; ) ); sock.write( \u0026#34;GET \u0026#34; + path + \u0026#34; HTTP/1.1\\r\\nHost: \u0026#34; + host + \u0026#34;\\r\\nConnection: close\\r\\n\\r\\n\u0026#34; ); sock.shutdown( SHUT_WR ); while ( !sock.eof() ) { string recvd; sock.read( recvd ); cout \u0026lt;\u0026lt; recvd; } sock.close(); return; } int main( int argc, char* argv[] ) { try { if ( argc \u0026lt;= 0 ) { abort(); // For sticklers: don\u0026#39;t try to access argv[0] if argc \u0026lt;= 0. } auto args = span( argv, argc ); // The program takes two command-line arguments: the hostname and \u0026#34;path\u0026#34; part of the URL. // Print the usage message unless there are these two arguments (plus the program name // itself, so arg count = 3 in total). if ( argc != 3 ) { cerr \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; args.front() \u0026lt;\u0026lt; \u0026#34; HOST PATH\\n\u0026#34;; cerr \u0026lt;\u0026lt; \u0026#34;\\tExample: \u0026#34; \u0026lt;\u0026lt; args.front() \u0026lt;\u0026lt; \u0026#34; stanford.edu /class/cs144\\n\u0026#34;; return EXIT_FAILURE; } // Get the command-line arguments. const string host { args[1] }; const string path { args[2] }; // Call the student-written function. get_URL( host, path ); } catch ( const exception\u0026amp; e ) { cerr \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return EXIT_FAILURE; } return EXIT_SUCCESS; } 进入build目录执行make\n运行./apps/webget cs144.keithw.org /hello：\n回到minnow目录运行 cmake --build build --target check webget：\n3.5 实现内存中的可靠字节流（ByteStream） 你将在一台计算机的内存中实现一个提供这种抽象的对象。字节在 “输入” 侧被写入，并可以从 “输出” 侧以相同的顺序被读取。这个字节流是有限的：写入者可以结束输入，之后就不能再写入更多字节。当读取者读到流的末尾时，它将到达 “EOF”（文件结束），并且不能再读取更多字节。\n你的字节流也将进行流量控制，以在任何给定时间限制其内存消耗。该对象在初始化时带有特定的 “容量”：即在任何给定时刻它愿意在自己的内存中存储的最大字节数。字节流将限制写入者在任何给定时刻可以写入的量，以确保流不会超过其存储容量。当读取者读取字节并从流中排出它们时，写入者被允许写入更多。你的字节流用于单个线程中 —— 你不必担心并发的写入者 / 读取者、锁定或竞争条件。\n需要明确的是：字节流是有限的，但在写入者结束输入并完成流之前，它可以几乎是任意长的。你的实现必须能够处理比容量长得多的流。容量限制了在给定时刻内存中（已写入但尚未读取）的字节数，但不限制流的长度。一个容量只有一个字节的对象仍然可以承载一个长达数 TB 的流，只要写入者一次写入一个字节，并且在写入者被允许写入下一个字节之前，读取者读取每个字节。\nwriter的接口如下:\n1 2 3 4 5 6 7 void push( std::string data ); // Push data to stream, but only as much as available capacity allows. void close(); // Signal that the stream has reached its ending. Nothing more will be written.* bool is_closed() const; // Has the stream been closed? uint64_t available_capacity() const; // How many bytes can be pushed to the stream right now? uint64_t bytes_pushed() const; // Total number of bytes cumulatively pushed to the stream reader的接口如下:\n1 2 3 4 5 6 std::string_view peek() const; // Peek at the next bytes in the buffer void pop( uint64_t len ); // Remove `len` bytes from the buffer bool is_finished() const; // Is the stream finished (closed and fully popped)? bool has_error() const; // Has the stream had an error? uint64_t bytes_buffered() const; // Number of bytes currently buffered (pushed and not popped) uint64_t bytes_popped() const; // Total number of bytes cumulatively popped from stream 请打开 “src/byte_stream.hh” 和 “src/byte_stream.cc” 文件，并实现一个提供此接口的对象。在开发字节流实现的过程中，你可以使用 “cmake --build build --target check0” 运行自动化测试。如果所有测试通过，check0 测试将运行你的实现的速度基准测试。对于本课程而言，任何速度快于 0.1 Gbit/s（换句话说，每秒 1 亿比特）的都是可以接受的。（一个实现有可能执行速度快于 10 Gbit/s，但这取决于你的计算机速度，不是必需的。）\nbyte_stream.hh:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #pragma once #include \u0026lt;cstdint\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;string_view\u0026gt; class Reader; class Writer; class ByteStream { public: explicit ByteStream( uint64_t capacity ); // Helper functions (provided) to access the ByteStream\u0026#39;s Reader and Writer interfaces Reader\u0026amp; reader(); const Reader\u0026amp; reader() const; Writer\u0026amp; writer(); const Writer\u0026amp; writer() const; void set_error() { error_ = true; }; // Signal that the stream suffered an error. bool has_error() const { return error_; }; // Has the stream had an error? protected: // Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces. uint64_t capacity_; bool error_ {}; std::deque\u0026lt;std::string\u0026gt; buffer_ {}; bool is_closed_ {}; uint64_t pushcnt_ {}; uint64_t popcnt_ {}; uint64_t buffer_bytes_size_ {}; }; class Writer : public ByteStream { public: void push( std::string data ); // Push data to stream, but only as much as available capacity allows. void close(); // Signal that the stream has reached its ending. Nothing more will be written. bool is_closed() const; // Has the stream been closed? uint64_t available_capacity() const; // How many bytes can be pushed to the stream right now? uint64_t bytes_pushed() const; // Total number of bytes cumulatively pushed to the stream }; class Reader : public ByteStream { public: std::string_view peek() const; // Peek at the next bytes in the buffer void pop( uint64_t len ); // Remove `len` bytes from the buffer bool is_finished() const; // Is the stream finished (closed and fully popped)? uint64_t bytes_buffered() const; // Number of bytes currently buffered (pushed and not popped) uint64_t bytes_popped() const; // Total number of bytes cumulatively popped from stream }; /* * read: A (provided) helper function thats peeks and pops up to `len` bytes * from a ByteStream Reader into a string; */ void read( Reader\u0026amp; reader, uint64_t len, std::string\u0026amp; out ); byte_stream.cc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026#34;byte_stream.hh\u0026#34; using namespace std; ByteStream::ByteStream( uint64_t capacity ) : capacity_( capacity ) {} bool Writer::is_closed() const { // Your code here. return is_closed_; } void Writer::push( string data ) { // Your code here. if ( is_closed_ || available_capacity() == 0 || data.empty() ) { return; } uint64_t const push_size = std::min( data.size(), available_capacity() ); if ( push_size \u0026lt; data.size() ) { data = data.substr( 0, push_size ); } buffer_.push_back( std::move( data ) ); buffer_bytes_size_ += push_size; pushcnt_ += push_size; return; } void Writer::close() { // Your code here. is_closed_ = true; } uint64_t Writer::available_capacity() const { // Your code here. return ( capacity_ - buffer_bytes_size_ ); } uint64_t Writer::bytes_pushed() const { // Your code here. return pushcnt_; } bool Reader::is_finished() const { // Your code here. return ( is_closed_ \u0026amp;\u0026amp; pushcnt_ == popcnt_ ); } uint64_t Reader::bytes_popped() const { // Your code here. return popcnt_; } string_view Reader::peek() const { // Your code here. if ( buffer_.empty() ) { return {}; } return std::string_view( buffer_.front() ); } void Reader::pop( uint64_t len ) { // Your code here. uint64_t pop_size = std::min( len, buffer_bytes_size_ ); buffer_bytes_size_ -= pop_size; popcnt_ += pop_size; while ( pop_size \u0026gt; 0 ) { uint64_t const to_pop_size = buffer_.front().size(); if ( to_pop_size \u0026lt;= pop_size ) { buffer_.pop_front(); pop_size -= to_pop_size; } else { buffer_.front().erase( 0, pop_size ); pop_size = 0; } } return; } uint64_t Reader::bytes_buffered() const { // Your code here. return pushcnt_ - popcnt_; } 执行自动化测试cmake --build build --target check0：\nCheck0 Over !! ","date":"2024-11-07T13:59:07+08:00","permalink":"https://SilentThink.github.io/p/cs144-lab-0/","title":"CS144 Lab 0"},{"content":"Title:hello world 1 .\\hugo.exe new site dev 1 ./hugo server -D 1 .\\hugo.exe new content post/myFirstBlog/index.md ","date":"2024-11-07T13:59:07+08:00","permalink":"https://SilentThink.github.io/p/myfirstblog/","title":"MyFirstBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://SilentThink.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://SilentThink.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://SilentThink.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://SilentThink.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://SilentThink.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://SilentThink.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://SilentThink.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://SilentThink.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://SilentThink.github.io/p/emoji-support/","title":"Emoji Support"}]