[{"content":"Lab 0：networking warmup 0.介绍 本次热身任务中，你需要在自己的计算机上安装 Linux 系统，学习如何手动通过互联网执行一些任务，用 C++ 编写一个小程序从互联网上获取网页，并在内存中实现网络的一个关键抽象概念：在写入者和读取者之间的可靠字节流。\n1. GNU/Linux环境配置 windows: 我使用的环境为Ubuntu 22.04 @ WSL2\n运行以下命令安装需要的包\n1 2 sudo apt update \u0026amp;\u0026amp; sudo apt install git cmake gdb build-essential clang \\ clang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark 项目编译运行及调试需要的g++ 版本:13及以上\nMac OS: 官方文档中的建议：\nIf you have a 2020–24 MacBook (with the ARM64 M1/M2/M3 chips), VirtualBox will\nnot successfully run. Instead, please install the UTM virtual machine software and our\nARM64 virtual machine image from https://stanford.edu/class/cs144/vm_howto/ .\n我的配置方法——docker:\ndockerfile:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 FROM ubuntu:latest WORKDIR /usr/src/app RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ build-essential \\ g++-13 \\ clang-15 RUN update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-13 100 \\ \u0026amp;\u0026amp; update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-13 100 \\ \u0026amp;\u0026amp; update-alternatives --install /usr/bin/clang clang /usr/bin/clang-15 100 ENV CC=gcc ENV CXX=g++ RUN apt-get clean \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* CMD [ \u0026#34;/bin/bash\u0026#34;] 2. 手动完成网络任务 在 “Networking by hand” 部分，你需要手动完成两项任务：检索网页（就像网络浏览器一样）和发送电子邮件消息（就像电子邮件客户端一样）。这两项任务都依赖于一种称为可靠双向字节流的网络抽象概念。你将在终端中输入一系列字节，相同顺序的字节序列最终将被传递到另一台计算机（服务器）上运行的程序。服务器用它自己的字节序列进行响应，并将其传递回你的终端。\n2.1 获取一个网页 打开浏览器访问 http://cs144.keithw.org/hello 并观察结果 在linux终端中执行和浏览器一样的工作 ​\t(a) 运行 telnet cs144.keithw.org http\n这会告诉 telnet 程序在你的计算机和另一台名为 “cs144.keithw.org” 的计算机之间打开一个可靠的字节流，并且在那台计算机上运行特定的服务：用于万维网的超文本传输协议（“http” 服务）。如果你的计算机已正确设置并连接到互联网，你将看到如上图相应的输出。\n如果你想要退出这个连接，按住键盘的 ctrl 键然后按 ]，之后敲下回车键 Enter 即可 (b) 输入 GET /hello HTTP/1.1，这告诉服务器 URL 的路径部分（从第三个斜杠开始的部分）。\n​\t(c) 输入 Host: cs144.keithw.org，这告诉服务器 URL 的主机部分（在 “http://” 和第三个斜杠之间的部分）。\n​\t(d) 输入 Connection: close，这告诉服务器你已完成请求，并且它应在回复完成后尽快关闭连接。\n​\t(e) 再按一次回车键，这发送一个空行并告诉服务器你已完成 HTTP 请求。\n​\t(f) 如果一切顺利，你将看到与浏览器看到的相同响应，前面是 HTTP 头，它告诉浏览器如何解释响应。\n2.2 给自己发邮件 略：没有斯坦福的邮箱，无法完成这个任务\n2.3 监听与连接 你已经看到了用 telnet 能做什么：它是一个客户端程序，可以与其他计算机上运行的程序建立外出连接。现在是时候尝试运行一个简单的服务器了：即等待客户端连接它的程序。\n在一个终端窗口中，在你的虚拟机上运行 netcat -v -l -p 9090。\n让 netcat 保持运行状态。在另一个终端窗口中，运行 telnet localhost 9090。\n如果一切顺利，netcat 将会打印出类似 “Connection from localhost 53500 received! ” 的内容。\n现在尝试在任意一个终端窗口中输入内容 —— 无论是 netcat（服务器）窗口还是 telnet（客户端）窗口。注意，你在一个窗口中输入的任何内容都会出现在另一个窗口中，反之亦然。你必须按回车键才能传输字节。\n在 netcat 窗口中，通过输入 ctrl-C 退出程序。注意，telnet 程序也会立即退出。\n3. 使用操作系统流套接字编写网络程序 在本次热身实验的下一部分，你要编写一个简短程序从互联网获取网页。这会利用 Linux 内核及大多数其他操作系统提供的功能，即在两个程序间创建可靠双向字节流，比如一个程序在你的计算机上运行，另一个在互联网上的其他计算机（如 Web 服务器或 netcat 程序）上运行。此功能称为流套接字，对于程序和 Web 服务器来说，它就像普通文件描述符。\n但实际上，互联网并不直接提供可靠字节流服务，只是尽最大努力传送数据报，而数据报可能丢失、乱序、内容改变甚至被复制多次。连接两端的操作系统通常负责将 “尽力而为的数据报” 转换为 “可靠字节流”，这是通过 1981 年的传输控制协议（TCP）实现的。\n在本次实验中，你将借助操作系统对 TCP 的支持编写 “webget” 程序，创建 TCP 流套接字连接 Web 服务器获取页面。未来的实验中，你将自己实现传输控制协议，从不太可靠的数据报中创建可靠字节流。\n3.1 获取并部署原始代码 运行 git clone https://github.com/cs144/minnow 拉取代码 将项目部署到自己的github仓库 进入 Lab 0 的目录：cd minnow 创建build目录来编译程序： cmake -S . -B build 编译源代码：cmake --build build 查看是否安装g++13版本，对应的路径在哪：\n配置默认编译器：nano ~/.bashrc，在文件末尾添加以下两行代码：\n1 2 export CC=gcc-13 export CXX=clang++-14 ctrl+x,Enter 进行保存\n运行source ~/.bashrc进行更新\n创建build目录\n编译\n3.2 现代C++编码规范 参考：\nhttp://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines\nhttps://en.cppreference.com\n具体请看源文档：check0.pdf\n在push到github之前，运行 cmake --build build --target tidy 以获取有关如何改进与 C++ 编程实践相关的代码的建议，并运行 cmake --build build --target format 以一致地格式化代码。\n使用git:\nPlease make frequent small commits as you work, and use commit messages that identify what changed and why\n参考：\nhttps://guides.github.com/introduction/git-handbook\n3.3 阅读 Minnow 提供的源代码框架 请仔细阅读公共接口（在文件 util/socket.hh 和 util/file_descriptor.hh 中 “public:” 之后的部分。请注意，Socket 是一种 FileDescriptor 类型，而 TCPSocket 是一种 Socket 类型）。\n3.4 编写 webget 现在是时候实现 “webget” 了，这是一个使用操作系统的 TCP 支持和流套接字抽象从互联网上获取网页的程序 —— 就像你在本次实验的早些时候手动所做的那样。\n从构建目录中，在文本编辑器或集成开发环境（IDE）中打开 “../apps/webget.cc” 文件。 在 “get_URL” 函数中实现简单的 Web 客户端。 按照文件中的描述，使用之前用过的 HTTP（Web）请求格式。同时要使用 “TCPSocket” 和 “Address” 类。 明确了实现的具体位置和所需的类。 提示： 在 HTTP 中，每行必须以 “\\r\\n” 结尾，不能仅用 “\\n” 或 “endl”。强调了 HTTP 协议的格式要求。 客户端请求中要包含 “Connection: close”，告知服务器在本次请求后不再等待更多请求，服务器发送一个回复后就结束传出字节流。当套接字到达 “EOF” 时，表明传入字节流结束，客户端由此知道服务器已完成回复。详细说明了与服务器交互的关键设置。 确保读取并打印服务器的所有输出直到套接字到达 “EOF”，单次调用 “read” 是不够的。强调了要完整处理服务器的响应。 预计需要写大约十行代码，给出了代码量的大致预期。 通过运行 make 编译程序。\n测试程序。\n运行 ./apps/webget cs144.keithw.org /hello 进行测试。 比较与在浏览器中访问 “http://cs144.keithw.org/hello” 的结果以及与 2.1 节结果的差异。鼓励用任何 http URL 进行实验。 自动化测试： 当程序看似正常工作时，运行 “cmake --build build --target check webget” 进行自动化测试。 在实现 “get_URL” 函数之前，会看到特定的测试结果，包括编译检查通过但功能测试失败，并给出警告和错误信息。完成作业后，测试应全部通过。 webget.cc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026#34;socket.hh\u0026#34; #include \u0026#34;tcp_minnow_socket.hh\u0026#34; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;span\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void get_URL( const string\u0026amp; host, const string\u0026amp; path ) { CS144TCPSocket sock {}; sock.connect( Address( host, \u0026#34;http\u0026#34; ) ); sock.write( \u0026#34;GET \u0026#34; + path + \u0026#34; HTTP/1.1\\r\\nHost: \u0026#34; + host + \u0026#34;\\r\\nConnection: close\\r\\n\\r\\n\u0026#34; ); sock.shutdown( SHUT_WR ); while ( !sock.eof() ) { string recvd; sock.read( recvd ); cout \u0026lt;\u0026lt; recvd; } sock.close(); return; } int main( int argc, char* argv[] ) { try { if ( argc \u0026lt;= 0 ) { abort(); // For sticklers: don\u0026#39;t try to access argv[0] if argc \u0026lt;= 0. } auto args = span( argv, argc ); // The program takes two command-line arguments: the hostname and \u0026#34;path\u0026#34; part of the URL. // Print the usage message unless there are these two arguments (plus the program name // itself, so arg count = 3 in total). if ( argc != 3 ) { cerr \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; args.front() \u0026lt;\u0026lt; \u0026#34; HOST PATH\\n\u0026#34;; cerr \u0026lt;\u0026lt; \u0026#34;\\tExample: \u0026#34; \u0026lt;\u0026lt; args.front() \u0026lt;\u0026lt; \u0026#34; stanford.edu /class/cs144\\n\u0026#34;; return EXIT_FAILURE; } // Get the command-line arguments. const string host { args[1] }; const string path { args[2] }; // Call the student-written function. get_URL( host, path ); } catch ( const exception\u0026amp; e ) { cerr \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return EXIT_FAILURE; } return EXIT_SUCCESS; } 进入build目录执行make\n运行./apps/webget cs144.keithw.org /hello：\n回到minnow目录运行 cmake --build build --target check webget：\n3.5 实现内存中的可靠字节流（ByteStream） 你将在一台计算机的内存中实现一个提供这种抽象的对象。字节在 “输入” 侧被写入，并可以从 “输出” 侧以相同的顺序被读取。这个字节流是有限的：写入者可以结束输入，之后就不能再写入更多字节。当读取者读到流的末尾时，它将到达 “EOF”（文件结束），并且不能再读取更多字节。\n你的字节流也将进行流量控制，以在任何给定时间限制其内存消耗。该对象在初始化时带有特定的 “容量”：即在任何给定时刻它愿意在自己的内存中存储的最大字节数。字节流将限制写入者在任何给定时刻可以写入的量，以确保流不会超过其存储容量。当读取者读取字节并从流中排出它们时，写入者被允许写入更多。你的字节流用于单个线程中 —— 你不必担心并发的写入者 / 读取者、锁定或竞争条件。\n需要明确的是：字节流是有限的，但在写入者结束输入并完成流之前，它可以几乎是任意长的。你的实现必须能够处理比容量长得多的流。容量限制了在给定时刻内存中（已写入但尚未读取）的字节数，但不限制流的长度。一个容量只有一个字节的对象仍然可以承载一个长达数 TB 的流，只要写入者一次写入一个字节，并且在写入者被允许写入下一个字节之前，读取者读取每个字节。\nwriter的接口如下:\n1 2 3 4 5 6 7 void push( std::string data ); // Push data to stream, but only as much as available capacity allows. void close(); // Signal that the stream has reached its ending. Nothing more will be written.* bool is_closed() const; // Has the stream been closed? uint64_t available_capacity() const; // How many bytes can be pushed to the stream right now? uint64_t bytes_pushed() const; // Total number of bytes cumulatively pushed to the stream reader的接口如下:\n1 2 3 4 5 6 std::string_view peek() const; // Peek at the next bytes in the buffer void pop( uint64_t len ); // Remove `len` bytes from the buffer bool is_finished() const; // Is the stream finished (closed and fully popped)? bool has_error() const; // Has the stream had an error? uint64_t bytes_buffered() const; // Number of bytes currently buffered (pushed and not popped) uint64_t bytes_popped() const; // Total number of bytes cumulatively popped from stream 请打开 “src/byte_stream.hh” 和 “src/byte_stream.cc” 文件，并实现一个提供此接口的对象。在开发字节流实现的过程中，你可以使用 “cmake --build build --target check0” 运行自动化测试。如果所有测试通过，check0 测试将运行你的实现的速度基准测试。对于本课程而言，任何速度快于 0.1 Gbit/s（换句话说，每秒 1 亿比特）的都是可以接受的。（一个实现有可能执行速度快于 10 Gbit/s，但这取决于你的计算机速度，不是必需的。）\nbyte_stream.hh:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #pragma once #include \u0026lt;cstdint\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;string_view\u0026gt; class Reader; class Writer; class ByteStream { public: explicit ByteStream( uint64_t capacity ); // Helper functions (provided) to access the ByteStream\u0026#39;s Reader and Writer interfaces Reader\u0026amp; reader(); const Reader\u0026amp; reader() const; Writer\u0026amp; writer(); const Writer\u0026amp; writer() const; void set_error() { error_ = true; }; // Signal that the stream suffered an error. bool has_error() const { return error_; }; // Has the stream had an error? protected: // Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces. uint64_t capacity_; bool error_ {}; std::deque\u0026lt;std::string\u0026gt; buffer_ {}; bool is_closed_ {}; uint64_t pushcnt_ {}; uint64_t popcnt_ {}; uint64_t buffer_bytes_size_ {}; }; class Writer : public ByteStream { public: void push( std::string data ); // Push data to stream, but only as much as available capacity allows. void close(); // Signal that the stream has reached its ending. Nothing more will be written. bool is_closed() const; // Has the stream been closed? uint64_t available_capacity() const; // How many bytes can be pushed to the stream right now? uint64_t bytes_pushed() const; // Total number of bytes cumulatively pushed to the stream }; class Reader : public ByteStream { public: std::string_view peek() const; // Peek at the next bytes in the buffer void pop( uint64_t len ); // Remove `len` bytes from the buffer bool is_finished() const; // Is the stream finished (closed and fully popped)? uint64_t bytes_buffered() const; // Number of bytes currently buffered (pushed and not popped) uint64_t bytes_popped() const; // Total number of bytes cumulatively popped from stream }; /* * read: A (provided) helper function thats peeks and pops up to `len` bytes * from a ByteStream Reader into a string; */ void read( Reader\u0026amp; reader, uint64_t len, std::string\u0026amp; out ); byte_stream.cc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026#34;byte_stream.hh\u0026#34; using namespace std; ByteStream::ByteStream( uint64_t capacity ) : capacity_( capacity ) {} bool Writer::is_closed() const { // Your code here. return is_closed_; } void Writer::push( string data ) { // Your code here. if ( is_closed_ || available_capacity() == 0 || data.empty() ) { return; } uint64_t const push_size = std::min( data.size(), available_capacity() ); if ( push_size \u0026lt; data.size() ) { data = data.substr( 0, push_size ); } buffer_.push_back( std::move( data ) ); buffer_bytes_size_ += push_size; pushcnt_ += push_size; return; } void Writer::close() { // Your code here. is_closed_ = true; } uint64_t Writer::available_capacity() const { // Your code here. return ( capacity_ - buffer_bytes_size_ ); } uint64_t Writer::bytes_pushed() const { // Your code here. return pushcnt_; } bool Reader::is_finished() const { // Your code here. return ( is_closed_ \u0026amp;\u0026amp; pushcnt_ == popcnt_ ); } uint64_t Reader::bytes_popped() const { // Your code here. return popcnt_; } string_view Reader::peek() const { // Your code here. if ( buffer_.empty() ) { return {}; } return std::string_view( buffer_.front() ); } void Reader::pop( uint64_t len ) { // Your code here. uint64_t pop_size = std::min( len, buffer_bytes_size_ ); buffer_bytes_size_ -= pop_size; popcnt_ += pop_size; while ( pop_size \u0026gt; 0 ) { uint64_t const to_pop_size = buffer_.front().size(); if ( to_pop_size \u0026lt;= pop_size ) { buffer_.pop_front(); pop_size -= to_pop_size; } else { buffer_.front().erase( 0, pop_size ); pop_size = 0; } } return; } uint64_t Reader::bytes_buffered() const { // Your code here. return pushcnt_ - popcnt_; } 执行自动化测试cmake --build build --target check0：\nCheck0 Over !! ","date":"2024-11-07T13:59:07+08:00","permalink":"https://SilentThink.github.io/p/cs144-lab-0/","title":"CS144 Lab 0"},{"content":"Title:hello world 1 .\\hugo.exe new site dev 1 ./hugo server -D 1 .\\hugo.exe new content post/myFirstBlog/index.md ","date":"2024-11-07T13:59:07+08:00","permalink":"https://SilentThink.github.io/p/myfirstblog/","title":"MyFirstBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://SilentThink.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://SilentThink.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://SilentThink.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://SilentThink.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://SilentThink.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://SilentThink.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://SilentThink.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://SilentThink.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://SilentThink.github.io/p/emoji-support/","title":"Emoji Support"}]